import React, { useState, useEffect, useMemo } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Stepper,
  Step,
  StepLabel,
  Box,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Typography,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  IconButton,
  Autocomplete,
  Chip,
  Grid,
  Card,
  CardContent,
  CircularProgress,
  Divider,
  Switch,
  FormControlLabel,
  Avatar,
  Paper,
  Alert,
  Tooltip,
  ListItemAvatar,
  Checkbox,
} from "@mui/material";
import { DatePicker, TimePicker } from "@mui/x-date-pickers";
import {
  Add,
  Remove,
  Delete,
  Group,
  Person,
  Upload,
  AttachMoney,
  SportsTennis,
  Schedule,
  MoveUp,
  Close,
} from "@mui/icons-material";
import { useFormik } from "formik";
import * as Yup from "yup";
import dayjs, { Dayjs } from "dayjs";
import {
  useCourts,
  useMembers,
  useGroups,
  useCreateSession,
  useUpdateSession,
  getSettings,
  getOrCreateSettings,
} from "../hooks";
import {
  Session,
  SessionExpense,
  Member,
  Court,
  Group as GroupType,
  AppSettings,
} from "../types";
import {
  formatCurrency,
  calculateSessionDuration,
  isAutoGeneratedSessionName,
  generateSessionName,
  getCurrentUserLogin,
  formatDate,
  formatTime,
} from "../utils";
import { ScheduledNotification } from "../types/notification";
import { scheduledNotificationService } from "../services/scheduledNotificationService";

interface SessionFormProps {
  open: boolean;
  onClose: () => void;
  onSuccess: () => void;
  editingSession?: Session | null;
}

interface CustomMember {
  id: string;
  name: string;
  isCustom: boolean;
  isWoman: boolean;
  avatar?: string;
}

interface ExpenseWithMembers extends SessionExpense {
  assignedMembers: string[];
}

const steps = ["Th√¥ng tin c∆° b·∫£n", "Ch·ªçn th√†nh vi√™n", "S·∫£nh ch·ªù", "Chi ph√≠"];
const SessionForm: React.FC<SessionFormProps> = ({
  open,
  onClose,
  onSuccess,
  editingSession,
}) => {
  const { data: courts } = useCourts();
  const { data: members } = useMembers();
  const { data: groups } = useGroups();
  const createSessionMutation = useCreateSession();
  const updateSessionMutation = useUpdateSession();

  // State management
  const [activeStep, setActiveStep] = useState(0);
  const [selectedMembers, setSelectedMembers] = useState<CustomMember[]>([]);
  const [waitingList, setWaitingList] = useState<CustomMember[]>([]);
  const [expenses, setExpenses] = useState<ExpenseWithMembers[]>([]);
  const [courtCost, setCourtCost] = useState(0);
  const [shuttlecockCount, setShuttlecockCount] = useState(1);
  const [shuttlecockPrice, setShuttlecockPrice] = useState(25000);
  const [customMemberName, setCustomMemberName] = useState("");
  const [customMemberIsWoman, setCustomMemberIsWoman] = useState(false);
  const [customWaitingMemberName, setCustomWaitingMemberName] = useState("");
  const [customWaitingMemberIsWoman, setCustomWaitingMemberIsWoman] =
    useState(false);
  const [qrImage, setQrImage] = useState<string | null>(null);
  const [isNameManuallyEdited, setIsNameManuallyEdited] = useState(false);
  const [passWaitingList, setPassWaitingList] = useState<string[]>([]);
  const [currentUser, setCurrentUser] = useState<any>(null);
  const [isFixedBadmintonCost, setIsFixedBadmintonCost] = useState(false);
  const [fixedBadmintonCost, setFixedBadmintonCost] = useState(15000);
  const [settings, setSettings] = useState<AppSettings | null>(null);
  const [settingsLoading, setSettingsLoading] = useState(true);
  const [scheduledTime, setScheduledTime] = useState<Dayjs | null>(dayjs().add(1, 'hour'));

  const validationSchemas = [
    // Step 1: Basic Info
    Yup.object({
      name: Yup.string().required("T√™n l·ªãch l√† b·∫Øt bu·ªôc"),
      courtId: Yup.string().required("Vui l√≤ng ch·ªçn s√¢n"),
      date: Yup.date().required("Ng√†y l√† b·∫Øt bu·ªôc"),
      startTime: Yup.string().required("Gi·ªù b·∫Øt ƒë·∫ßu l√† b·∫Øt bu·ªôc"),
      endTime: Yup.string().required("Gi·ªù k·∫øt th√∫c l√† b·∫Øt bu·ªôc"),
      maxParticipants: Yup.number()
        .min(2, "T·ªëi thi·ªÉu 2 ng∆∞·ªùi")
        .max(60, "T·ªëi ƒëa 60 ng∆∞·ªùi")
        .required("S·ªë ng∆∞·ªùi t·ªëi ƒëa l√† b·∫Øt bu·ªôc"),
      priceSlot: Yup.number().min(0, "T·ªëi thi·ªÉu 0"),
    }),
    Yup.object({}), // Step 2
    Yup.object({}), // Step 3
    Yup.object({}), // Step 4
  ];

  // Memoize initial values so Formik doesn't reinitialize on every render
  const initialFormikValues = useMemo(() => {
    return {
      name: editingSession?.name ?? "",
      courtId: editingSession?.courtId ?? "",
      // use editingSession.date if exists, otherwise stable default date
      date: editingSession?.date ?? dayjs().add(1, "day").toDate(),
      startTime: editingSession?.startTime ?? "19:30",
      endTime: editingSession?.endTime ?? "21:30",
      maxParticipants: editingSession?.maxParticipants ?? 24,
      priceSlot: editingSession?.priceSlot ?? 0,
      isFixedBadmintonCost: editingSession?.isFixedBadmintonCost ?? false,
      fixedBadmintonCost: editingSession?.fixedBadmintonCost ?? 0,
      notes: editingSession?.notes ?? "",
      status: editingSession?.status ?? "scheduled",
      // keep host simple (string/id) or displayName to avoid object identity churn
      host: editingSession?.host ?? currentUser ?? "",
      // fallback order: session QR -> local qrImage state -> currentUser qrCode -> ""
      qrImage: editingSession?.qrImage ?? qrImage ?? currentUser?.qrCode ?? "",
    };
    // only recompute when these real dependencies change
  }, [editingSession, qrImage, currentUser?.qrCode, currentUser?.displayName]);

  const formik = useFormik({
    enableReinitialize: true,
    initialValues: initialFormikValues,
    validationSchema: validationSchemas[activeStep],
    onSubmit: async (values) => {
      if (activeStep < steps.length - 1) {
        setActiveStep(activeStep + 1);
      } else {
        await handleSaveSession(values);
      }
    },
  });

  // Schedule notification
  const handleScheduleNotification = async (scheduledData: any) => {
    try {
      const notification: Omit<
        ScheduledNotification,
        "id" | "status" | "createdAt"
      > = {
        title: "üçª ƒêi v·ª•t th√¥iiii! üè∏",
        body: `üìç ${scheduledData?.courts?.name ?? ''}\n
              üóìÔ∏è ${formatDate(scheduledData?.date)}\n
              üï¢ ${formatTime(scheduledData?.startTime)} - ${formatTime(scheduledData?.endTime)}`,
        scheduledTime: scheduledTime.toDate(),
        targetType: "all",
        createdBy: currentUser?.id || "",
      };

      await scheduledNotificationService.createScheduledNotification(
        notification
      );
    } catch (error: any) {
      console.error("Error scheduling notification:", error);
    } 
  };

  const handleSaveSession = async (values: any) => {
    try {
      const selectedCourt = courts?.find((c) => c.id === values.courtId);
      if (!selectedCourt) return;

      const shuttlecockCost = shuttlecockCount * shuttlecockPrice;
      const totalFixedCost = courtCost + shuttlecockCost;
      const totalExpenses = expenses.reduce((sum, exp) => sum + exp.amount, 0);
      const totalCost = totalFixedCost + totalExpenses;

      const sessionExpenses = [
        ...(courtCost > 0
          ? [
              {
                id: "court-cost",
                name: "Ti·ªÅn s√¢n",
                amount: courtCost,
                type: "court" as const,
                description: `Ph√≠ thu√™ s√¢n`,
              },
            ]
          : []),
        ...(shuttlecockCost > 0
          ? [
              {
                id: "shuttlecock-cost",
                name: "Ti·ªÅn c·∫ßu",
                amount: shuttlecockCost,
                type: "shuttlecock" as const,
                description: `${shuttlecockCount} qu·∫£ x ${formatCurrency(
                  shuttlecockPrice
                )}`,
              },
            ]
          : []),
        ...expenses.map((exp) => ({
          id: exp.id,
          name: exp.name,
          amount: exp.amount,
          type: exp.type,
          description: exp.description,
        })),
      ];

      const sessionData = {
        name: values.name,
        courtId: values.courtId,
        date: values.date,
        startTime: values.startTime,
        endTime: values.endTime,
        maxParticipants: values.maxParticipants,
        priceSlot: values.priceSlot,
        isFixedBadmintonCost: isFixedBadmintonCost,
        fixedBadmintonCost: fixedBadmintonCost,
        currentParticipants: selectedMembers.length,
        status: values.status,
        createdBy: editingSession?.createdBy || currentUser?.memberId || "",
        passWaitingList: passWaitingList, // ‚úÖ Th√™m v√†o
        host: {
          name: currentUser.displayName,
          isCustom: false,
          memberId: currentUser.memberId,
        },

        // C·∫¢I THI·ªÜN: L∆∞u c·∫£ memberName cho custom members
        members: selectedMembers.map((member) => ({
          memberId: member.id,
          memberName: member.name, // QUAN TR·ªåNG: Lu√¥n l∆∞u memberName
          isPresent:
            editingSession?.members.find((m) => m.memberId === member.id)
              ?.isPresent || false,
          isCustom: member.isCustom, // QUAN TR·ªåNG: L∆∞u flag isCustom
          isWoman: member.isWoman || false,
          avatar: member.avatar || "",
        })),

        // C·∫¢I THI·ªÜN: L∆∞u c·∫£ memberName cho custom members trong waiting list
        waitingList: waitingList.map((member, index) => ({
          memberId: member.id,
          memberName: member.name, // QUAN TR·ªåNG: Lu√¥n l∆∞u memberName
          addedAt: new Date(),
          priority: index + 1,
          isCustom: member.isCustom, // QUAN TR·ªåNG: L∆∞u flag isCustom
          isWoman: member.isWoman || false,
          avatar: member.avatar || "",
        })),

        expenses: sessionExpenses,
        totalCost,
        costPerPerson:
          selectedMembers.length > 0
            ? totalFixedCost / selectedMembers.length
            : 0,
        settlements: editingSession?.settlements || [],
        notes: values.notes,
        qrImage: qrImage || formik.values.qrImage || currentUser?.qrCode || "",

        ...(editingSession
          ? { updatedAt: new Date() }
          : { createdAt: new Date(), updatedAt: new Date() }),
      };

      console.log("Saving session with custom members:", {
        selectedMembers: selectedMembers.map((m) => ({
          id: m.id,
          name: m.name,
          isCustom: m.isCustom,
          isWoman: m.isWoman,
          avatar: m.avatar,
        })),
        waitingList: waitingList.map((m) => ({
          id: m.id,
          name: m.name,
          isCustom: m.isCustom,
          isWoman: m.isWoman || false,
          avatar: m.avatar || "",
        })),
      });

      if (editingSession) {
        await updateSessionMutation.mutateAsync({
          id: editingSession.id,
          data: sessionData,
        });
      } else {
        await createSessionMutation.mutateAsync(sessionData);
        const scheduledData = {
          ...sessionData,
          courts: selectedCourt,
        }
        const combinedDateTime = dayjs(`${sessionData.date}T${sessionData.startTime}:00`);
        // C·∫≠p nh·∫≠t gi√° tr·ªã cho scheduledTime
        setScheduledTime(combinedDateTime);
        await handleScheduleNotification(scheduledData);
      }

      onSuccess();
      handleClose();
    } catch (error) {
      console.error("Error saving session:", error);
    }
  };

  const handleClose = () => {
    setActiveStep(0);
    setSelectedMembers([]);
    setWaitingList([]);
    setExpenses([]);
    setCourtCost(0);
    setShuttlecockCount(1);
    setShuttlecockPrice(25000);
    setQrImage(null);
    setCustomMemberName("");
    setCustomMemberIsWoman(false);
    setCustomWaitingMemberName("");
    setCustomWaitingMemberIsWoman(false);
    formik.resetForm();
    setIsNameManuallyEdited(false); // ‚úÖ Reset flag
    setPassWaitingList([]);
    onClose();
  };
  const addMemberFromList = (member: Member) => {
    const customMember: CustomMember = {
      id: member.id,
      name: member.name,
      isCustom: false,
      isWoman: member.isWoman || false,
      avatar: member.avatar || "",
    };
    if (selectedMembers.length < formik.values.maxParticipants) {
      if (!selectedMembers.some((m) => m.id === member.id)) {
        setSelectedMembers([...selectedMembers, customMember]);
      }
    } else {
      if (!waitingList.some((m) => m.id === member.id)) {
        setWaitingList([...waitingList, customMember]);
      }
    }
  };

  const addMemberFromGroup = (group: GroupType) => {
    const groupMembers =
      members?.filter((m) => group.memberIds.includes(m.id)) || [];
    const newSelectedMembers = [...selectedMembers];
    const newWaitingList = [...waitingList];

    groupMembers.forEach((member) => {
      const customMember: CustomMember = {
        id: member.id,
        name: member.name,
        isCustom: false,
        isWoman: member.isWoman || false,
        avatar: member.avatar || "",
      };

      if (
        !newSelectedMembers.some((m) => m.id === member.id) &&
        !newWaitingList.some((m) => m.id === member.id)
      ) {
        if (newSelectedMembers.length < formik.values.maxParticipants) {
          newSelectedMembers.push(customMember);
        } else {
          newWaitingList.push(customMember);
        }
      }
    });

    setSelectedMembers(newSelectedMembers);
    setWaitingList(newWaitingList);
  };

  const addCustomMember = () => {
    if (!customMemberName.trim()) return;

    const customMember: CustomMember = {
      id: `custom-member-${Date.now()}-${Math.random()
        .toString(36)
        .substr(2, 9)}`, // ID unique h∆°n
      name: customMemberName.trim(),
      isCustom: true,
      isWoman: customMemberIsWoman,
    };

    if (selectedMembers.length < formik.values.maxParticipants) {
      setSelectedMembers([...selectedMembers, customMember]);
    } else {
      setWaitingList([...waitingList, customMember]);
    }

    setCustomMemberName("");
    setCustomMemberIsWoman(false);
    // console.log("Added custom member:", customMember);
  };

  const addCustomWaitingMember = () => {
    if (!customWaitingMemberName.trim()) return;

    const customMember: CustomMember = {
      id: `custom-waiting-${Date.now()}-${Math.random()
        .toString(36)
        .substr(2, 9)}`, // ID unique h∆°n
      name: customWaitingMemberName.trim(),
      isCustom: true,
      isWoman: customWaitingMemberIsWoman,
    };

    setWaitingList([...waitingList, customMember]);
    setCustomWaitingMemberName("");
    setCustomWaitingMemberIsWoman(false);
    // console.log("Added custom waiting member:", customMember);
  };

  const removeMember = (member: CustomMember) => {
    const newSelectedMembers = selectedMembers.filter(
      (m) => m.id !== member.id
    );
    setSelectedMembers(newSelectedMembers);

    if (
      waitingList.length > 0 &&
      newSelectedMembers.length < formik.values.maxParticipants
    ) {
      const firstWaiting = waitingList[0];
      setWaitingList(waitingList.slice(1));
      setSelectedMembers([...newSelectedMembers, firstWaiting]);
    }
  };

  const removeFromWaitingList = (member: CustomMember) => {
    setWaitingList(waitingList.filter((m) => m.id !== member.id));
  };

  const moveFromWaitingToMain = (member: CustomMember) => {
    if (selectedMembers.length < formik.values.maxParticipants) {
      setWaitingList(waitingList.filter((m) => m.id !== member.id));
      setSelectedMembers([...selectedMembers, member]);
    }
  };

  const addExpense = () => {
    const newExpense: ExpenseWithMembers = {
      id: Date.now().toString(),
      name: "",
      amount: 0,
      type: "other",
      description: "",
      assignedMembers: [],
    };
    setExpenses([...expenses, newExpense]);
  };

  const updateExpense = (
    id: string,
    field: keyof ExpenseWithMembers,
    value: any
  ) => {
    setExpenses(
      expenses.map((exp) => (exp.id === id ? { ...exp, [field]: value } : exp))
    );
  };

  const removeExpense = (id: string) => {
    setExpenses(expenses.filter((exp) => exp.id !== id));
  };

  const handleQrImageUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const data = e.target?.result as string;
        setQrImage(data);
        // update formik field so formik.values.qrImage lu√¥n sync
        try {
          formik.setFieldValue("qrImage", data);
        } catch (err) {
          // formik may not be ready in very early lifecycle ‚Äî ignore safely
        }
      };
      reader.readAsDataURL(file);
    }
  };

  // Load settings t·ª´ Firebase khi component mount
  useEffect(() => {
    let isMounted = true;

    const loadSettings = async () => {
      try {
        const appSettings = await getOrCreateSettings();
        if (isMounted) {
          setSettings(appSettings);
          // ƒê·∫∑t gi√° c·∫ßu m·∫∑c ƒë·ªãnh t·ª´ settings
          setShuttlecockPrice(appSettings.defaultShuttlecockCost || 25000);
          setIsFixedBadmintonCost(appSettings.isFixedBadmintonCost || false);
          setFixedBadmintonCost(appSettings.fixedBadmintonCost || null);
        }
      } catch (error) {
        console.error("Error loading settings:", error);
      } finally {
        if (isMounted) {
          setSettingsLoading(false);
        }
      }
    };

    loadSettings();

    return () => {
      isMounted = false;
    };
  }, []);

  useEffect(() => {
    let isMounted = true;
    (async () => {
      const user = await getCurrentUserLogin();
      if (!isMounted) return;
      setCurrentUser(user);

      if (!editingSession && user?.qrCode) {
        // only set if qrImage not already set
        setQrImage((prev) => prev || user.qrCode);
        // and update formik field once (safe because initialFormikValues memo uses currentUser)
        try {
          formik.setFieldValue("qrImage", (prev) => prev || user.qrCode);
        } catch (e) {}
      }
    })();
    return () => {
      isMounted = false;
    };
    // run once on mount
  }, []);

  useEffect(() => {
    // Ch·ªâ auto-generate n·∫øu:
    // 1. User ch∆∞a t·ª± edit name, HO·∫∂C
    // 2. Name hi·ªán t·∫°i l√† auto-generated (cho ph√©p update khi ƒë·ªïi date/time)
    const shouldAutoGenerate =
      !isNameManuallyEdited || isAutoGeneratedSessionName(formik.values.name);

    if (shouldAutoGenerate && formik.values.date) {
      const autoName = generateSessionName(
        formik.values.date,
        formik.values.startTime,
        formik.values.endTime
      );

      // Ch·ªâ update n·∫øu name kh√°c v·ªõi gi√° tr·ªã hi·ªán t·∫°i
      if (autoName !== formik.values.name) {
        formik.setFieldValue("name", autoName);
      }
    }
    if (editingSession && members) {
      // ‚úÖ Check xem name c√≥ ph·∫£i auto-generated kh√¥ng
      // N·∫øu kh√¥ng ph·∫£i, ƒë√°nh d·∫•u l√† manually edited
      if (!isAutoGeneratedSessionName(editingSession.name)) {
        setIsNameManuallyEdited(true);
      }
    }
  }, [
    editingSession,
    formik.values.date,
    formik.values.startTime,
    formik.values.endTime,
  ]);

  const getStepContent = (step: number) => {
    switch (step) {
      case 0:
        return (
          <Box sx={{ pt: 2 }}>
            <Grid container spacing={2}>
              <Grid item xs={12}>
                <TextField
                  fullWidth
                  name="name"
                  label="T√™n l·ªãch ƒë√°nh"
                  value={formik.values.name}
                  onChange={(e) => {
                    formik.handleChange(e);
                    // User ƒëang t·ª± ch·ªânh s·ª≠a t√™n
                    setIsNameManuallyEdited(true);
                  }}
                  onBlur={formik.handleBlur}
                  error={formik.touched.name && Boolean(formik.errors.name)}
                  helperText={
                    formik.touched.name && formik.errors.name
                      ? formik.errors.name
                      : "T√™n t·ª± ƒë·ªông theo ng√†y/gi·ªù. C√≥ th·ªÉ ch·ªânh s·ª≠a l·∫°i."
                  }
                  placeholder="VD: Th·ª© 5, 02/10/2025, 19:30-20:30"
                  InputProps={{
                    endAdornment: isAutoGeneratedSessionName(
                      formik.values.name
                    ) ? (
                      <Tooltip title="T√™n ƒë∆∞·ª£c t·∫°o t·ª± ƒë·ªông">
                        <Schedule color="action" fontSize="small" />
                      </Tooltip>
                    ) : null,
                  }}
                />
              </Grid>

              <Grid item xs={12}>
                <FormControl fullWidth>
                  <InputLabel>Ch·ªçn s√¢n</InputLabel>
                  <Select
                    name="courtId"
                    value={formik.values.courtId}
                    onChange={formik.handleChange}
                    label="Ch·ªçn s√¢n"
                    error={
                      formik.touched.courtId && Boolean(formik.errors.courtId)
                    }
                  >
                    {courts
                      ?.filter((court) => court.isActive)
                      .map((court) => (
                        <MenuItem key={court.id} value={court.id}>
                          <Box sx={{ display: "flex", alignItems: "center" }}>
                            <SportsTennis sx={{ mr: 1, fontSize: "small" }} />
                            {court.name} - {court.location} (
                            {formatCurrency(court.pricePerHour)}/gi·ªù)
                          </Box>
                        </MenuItem>
                      ))}
                  </Select>
                </FormControl>
              </Grid>

              <Grid item xs={12} sm={4}>
                <DatePicker
                  label="Ng√†y"
                  value={formik.values.date ? dayjs(formik.values.date) : null}
                  onChange={(newValue) => {
                    formik.setFieldValue("date", newValue?.toDate());
                  }}
                  dayOfWeekFormatter={(day) => {
                    // ‚úÖ TH√äM
                    const dayNames = ["CN", "T2", "T3", "T4", "T5", "T6", "T7"];
                    return dayNames[day];
                  }}
                  slotProps={{
                    textField: {
                      fullWidth: true,
                      error: formik.touched.date && Boolean(formik.errors.date),
                      helperText:
                        formik.touched.date && formik.errors.date
                          ? String(formik.errors.date)
                          : undefined,
                    },
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={4}>
                <TimePicker
                  label="Gi·ªù b·∫Øt ƒë·∫ßu"
                  value={dayjs(`2000-01-01T${formik.values.startTime}`)}
                  onChange={(newValue) => {
                    formik.setFieldValue(
                      "startTime",
                      newValue?.format("HH:mm")
                    );
                  }}
                  slotProps={{
                    textField: {
                      fullWidth: true,
                      error:
                        formik.touched.startTime &&
                        Boolean(formik.errors.startTime),
                      helperText:
                        formik.touched.startTime && formik.errors.startTime,
                    },
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={4}>
                <TimePicker
                  label="Gi·ªù k·∫øt th√∫c"
                  value={dayjs(`2000-01-01T${formik.values.endTime}`)}
                  onChange={(newValue) => {
                    formik.setFieldValue("endTime", newValue?.format("HH:mm"));
                  }}
                  slotProps={{
                    textField: {
                      fullWidth: true,
                      error:
                        formik.touched.endTime &&
                        Boolean(formik.errors.endTime),
                      helperText:
                        formik.touched.endTime && formik.errors.endTime,
                    },
                  }}
                />
              </Grid>

              <Grid item xs={12} sm={4}>
                <TextField
                  fullWidth
                  name="maxParticipants"
                  label="S·ªë ng∆∞·ªùi t·ªëi ƒëa"
                  type="number"
                  value={formik.values.maxParticipants}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={
                    formik.touched.maxParticipants &&
                    Boolean(formik.errors.maxParticipants)
                  }
                  helperText={
                    formik.touched.maxParticipants &&
                    formik.errors.maxParticipants
                  }
                />
              </Grid>
              <Grid item xs={12} sm={4}>
                <TextField
                  fullWidth
                  name="priceSlot"
                  label="Ti·ªÅn slot c·ªë ƒë·ªãnh (VNƒê)"
                  type="number"
                  value={formik.values.priceSlot}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={
                    formik.touched.priceSlot && Boolean(formik.errors.priceSlot)
                  }
                  helperText={
                    formik.touched.priceSlot && formik.errors.priceSlot
                  }
                />
              </Grid>

              {isFixedBadmintonCost && (
                <Grid item xs={12} sm={4}>
                  <TextField
                    disabled
                    fullWidth
                    name="fixedBadmintonCost"
                    label="Gi√° c·∫ßu c·ªë ƒë·ªãnh cho n·ªØ"
                    type="number"
                    value={fixedBadmintonCost}
                    inputProps={{ min: 0 }}
                  />
                </Grid>
              )}

              {editingSession && (
                <Grid item xs={12} sm={6}>
                  <FormControl fullWidth>
                    <InputLabel>Tr·∫°ng th√°i</InputLabel>
                    <Select
                      name="status"
                      value={formik.values.status}
                      onChange={formik.handleChange}
                      label="Tr·∫°ng th√°i"
                    >
                      <MenuItem value="scheduled">
                        <Chip
                          label="ƒê√£ l√™n l·ªãch"
                          color="primary"
                          size="small"
                          sx={{ mr: 1 }}
                        />
                        ƒê√£ l√™n l·ªãch
                      </MenuItem>
                      <MenuItem value="ongoing">
                        <Chip
                          label="ƒêang di·ªÖn ra"
                          color="warning"
                          size="small"
                          sx={{ mr: 1 }}
                        />
                        ƒêang di·ªÖn ra
                      </MenuItem>
                      <MenuItem value="completed">
                        <Chip
                          label="ƒê√£ ho√†n th√†nh"
                          color="success"
                          size="small"
                          sx={{ mr: 1 }}
                        />
                        ƒê√£ ho√†n th√†nh
                      </MenuItem>
                      <MenuItem value="cancelled">
                        <Chip
                          label="ƒê√£ h·ªßy"
                          color="error"
                          size="small"
                          sx={{ mr: 1 }}
                        />
                        ƒê√£ h·ªßy
                      </MenuItem>
                    </Select>
                  </FormControl>
                </Grid>
              )}

              <Grid item xs={12}>
                <TextField
                  fullWidth
                  name="notes"
                  label="Ghi ch√∫"
                  placeholder="Ghi ch√∫ th√™m v·ªÅ l·ªãch ƒë√°nh..."
                  multiline
                  rows={3}
                  value={formik.values.notes}
                  onChange={formik.handleChange}
                />
              </Grid>

              <Grid item xs={12}>
                <Card variant="outlined">
                  <CardContent>
                    <Typography
                      variant="subtitle1"
                      gutterBottom
                      sx={{ display: "flex", alignItems: "center" }}
                    >
                      <AttachMoney sx={{ mr: 1 }} />
                      QR Code thanh to√°n (t√πy ch·ªçn)
                    </Typography>
                    <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
                      <input
                        accept="image/*"
                        style={{ display: "none" }}
                        id="qr-upload"
                        type="file"
                        onChange={handleQrImageUpload}
                      />
                      <label htmlFor="qr-upload">
                        <Button
                          variant="outlined"
                          component="span"
                          startIcon={<Upload />}
                        >
                          T·∫£i ·∫£nh QR
                        </Button>
                      </label>
                      {qrImage && (
                        <Button
                          variant="outlined"
                          color="error"
                          startIcon={<Delete />}
                          onClick={() => setQrImage(null)}
                        >
                          X√≥a
                        </Button>
                      )}
                    </Box>
                    {qrImage && (
                      <Box sx={{ mt: 2, textAlign: "center" }}>
                        <img
                          src={qrImage}
                          alt="QR Code"
                          style={{
                            maxWidth: 200,
                            maxHeight: 200,
                            border: "1px solid #ddd",
                            borderRadius: 8,
                          }}
                        />
                        <Typography
                          variant="caption"
                          display="block"
                          sx={{ mt: 1 }}
                        >
                          QR Code ƒë√£ t·∫£i l√™n
                        </Typography>
                      </Box>
                    )}
                  </CardContent>
                </Card>
              </Grid>
            </Grid>
          </Box>
        );
      case 1:
        return (
          <Box sx={{ pt: 2 }}>
            <Alert severity="info" sx={{ mb: 3 }}>
              ƒêang ch·ªçn:{" "}
              <strong>
                {selectedMembers.length}/{formik.values.maxParticipants}
              </strong>{" "}
              th√†nh vi√™n tham gia
            </Alert>

            {/* Add from member list */}
            <Card sx={{ mb: 2 }}>
              <CardContent>
                <Typography
                  variant="subtitle1"
                  gutterBottom
                  sx={{ display: "flex", alignItems: "center" }}
                >
                  <Person sx={{ mr: 1 }} />
                  Th√™m t·ª´ danh s√°ch th√†nh vi√™n
                </Typography>
                <Autocomplete
                  options={
                    members?.filter(
                      (member) =>
                        member.isActive &&
                        !selectedMembers.some((sm) => sm.id === member.id) &&
                        !waitingList.some((wm) => wm.id === member.id)
                    ) || []
                  }
                  getOptionLabel={(option) => `${option.name}`}
                  onChange={(_, value) => {
                    if (value) {
                      addMemberFromList(value);
                    }
                  }}
                  renderInput={(params) => (
                    <TextField
                      {...params}
                      label="T√¨m v√† th√™m th√†nh vi√™n"
                      size="small"
                    />
                  )}
                  renderOption={(props, option) => (
                    <Box component="li" {...props}>
                      {option.avatar ? (
                        <Avatar
                          src={option.avatar}
                          sx={{ mr: 2, width: 32, height: 32 }}
                        />
                      ) : (
                        <Avatar sx={{ mr: 2, width: 32, height: 32 }}>
                          {option.name.charAt(0)}
                        </Avatar>
                      )}

                      <Box>
                        <Typography variant="body2">{option.name}</Typography>
                        {/* <Typography variant="caption" color="text.secondary">
                          {option.skillLevel}
                        </Typography> */}
                      </Box>
                    </Box>
                  )}
                />
              </CardContent>
            </Card>

            {/* Add from groups */}
            <Card sx={{ mb: 2 }}>
              <CardContent>
                <Typography
                  variant="subtitle1"
                  gutterBottom
                  sx={{ display: "flex", alignItems: "center" }}
                >
                  <Group sx={{ mr: 1 }} />
                  Th√™m t·ª´ nh√≥m
                </Typography>
                {groups && groups.length > 0 ? (
                  <Grid container spacing={1}>
                    {groups.map((group) => (
                      <Grid item key={group.id}>
                        <Tooltip
                          title={`Th√™m t·∫•t c·∫£ ${group.memberIds.length} th√†nh vi√™n`}
                        >
                          <Chip
                            label={`${group.name} (${group.memberIds.length})`}
                            onClick={() => addMemberFromGroup(group)}
                            icon={<Group />}
                            variant="outlined"
                            clickable
                            color="primary"
                          />
                        </Tooltip>
                      </Grid>
                    ))}
                  </Grid>
                ) : (
                  <Typography variant="body2" color="text.secondary">
                    Ch∆∞a c√≥ nh√≥m n√†o ƒë∆∞·ª£c t·∫°o
                  </Typography>
                )}
              </CardContent>
            </Card>

            {/* Add custom member */}
            <Card sx={{ mb: 2 }}>
              <CardContent>
                <Typography
                  variant="subtitle1"
                  gutterBottom
                  sx={{ display: "flex", alignItems: "center" }}
                >
                  <Add sx={{ mr: 1 }} />
                  Th√™m t√™n t√πy ch·ªânh
                </Typography>
                <Box sx={{ display: "flex", gap: 1 }}>
                  <TextField
                    size="small"
                    label="T√™n th√†nh vi√™n"
                    placeholder="Nh·∫≠p t√™n..."
                    value={customMemberName}
                    onChange={(e) => setCustomMemberName(e.target.value)}
                    onKeyPress={(e) => e.key === "Enter" && addCustomMember()}
                    sx={{ flexGrow: 1 }}
                  />
                  <FormControlLabel
                    control={
                      <Checkbox
                        checked={customMemberIsWoman}
                        onChange={(e) =>
                          setCustomMemberIsWoman(e.target.checked)
                        }
                        name="isWoman"
                      />
                    }
                    label="N·ªØ"
                  />
                  <Button
                    variant="contained"
                    onClick={addCustomMember}
                    disabled={!customMemberName.trim()}
                    startIcon={<Add />}
                  >
                    Th√™m
                  </Button>
                </Box>
              </CardContent>
            </Card>

            {/* Selected members list */}
            <Card>
              <CardContent>
                <Typography variant="subtitle1" gutterBottom>
                  Danh s√°ch tham gia ({selectedMembers.length})
                </Typography>
                {selectedMembers.length === 0 ? (
                  <Alert severity="warning">
                    Ch∆∞a c√≥ th√†nh vi√™n n√†o ƒë∆∞·ª£c ch·ªçn
                  </Alert>
                ) : (
                  <List dense>
                    {selectedMembers.map((member, index) => (
                      <ListItem
                        key={member.id}
                        divider={index < selectedMembers.length - 1}
                      >
                        <ListItemAvatar>
                          {member.avatar ? (
                            <Avatar
                              src={member.avatar}
                              sx={{ mr: 2, width: 32, height: 32 }}
                            />
                          ) : (
                            <Avatar
                              sx={{
                                bgcolor: member.isCustom
                                  ? "secondary.main"
                                  : "primary.main",
                              }}
                            >
                              {member.isCustom ? (
                                <Person />
                              ) : (
                                member.name.charAt(0)
                              )}
                            </Avatar>
                          )}
                        </ListItemAvatar>
                        <ListItemText
                          primary={member.name}
                          secondary={
                            member.isCustom ? "T√™n t√πy ch·ªânh" : "Th√†nh vi√™n"
                          }
                        />
                        <ListItemSecondaryAction>
                          <Tooltip title="X√≥a kh·ªèi danh s√°ch">
                            <IconButton
                              edge="end"
                              onClick={() => removeMember(member)}
                              size="small"
                              color="error"
                            >
                              <Close />
                            </IconButton>
                          </Tooltip>
                        </ListItemSecondaryAction>
                      </ListItem>
                    ))}
                  </List>
                )}
              </CardContent>
            </Card>
          </Box>
        );
      case 2:
        return (
          <Box sx={{ pt: 2 }}>
            <Alert severity="info" sx={{ mb: 3 }}>
              S·∫£nh ch·ªù: <strong>{waitingList.length}</strong> ng∆∞·ªùi ƒëang ch·ªù
            </Alert>

            {/* Add from member list to waiting */}
            <Card sx={{ mb: 2 }}>
              <CardContent>
                <Typography
                  variant="subtitle1"
                  gutterBottom
                  sx={{ display: "flex", alignItems: "center" }}
                >
                  <Person sx={{ mr: 1 }} />
                  Th√™m t·ª´ danh s√°ch th√†nh vi√™n
                </Typography>
                <Autocomplete
                  options={
                    members?.filter(
                      (member) =>
                        member.isActive &&
                        !selectedMembers.some((sm) => sm.id === member.id) &&
                        !waitingList.some((wm) => wm.id === member.id)
                    ) || []
                  }
                  getOptionLabel={(option) => `${option.name}`}
                  onChange={(_, value) => {
                    if (value) {
                      const customMember: CustomMember = {
                        id: value.id,
                        name: value.name,
                        isCustom: false,
                        isWoman: value.isWoman,
                        avatar: value.avatar || "",
                      };
                      setWaitingList([...waitingList, customMember]);
                    }
                  }}
                  renderInput={(params) => (
                    <TextField
                      {...params}
                      label="Th√™m v√†o s·∫£nh ch·ªù"
                      size="small"
                    />
                  )}
                  renderOption={(props, option) => (
                    <Box component="li" {...props}>
                      {option.avatar ? (
                        <Avatar
                          src={option.avatar}
                          sx={{ mr: 2, width: 32, height: 32 }}
                        />
                      ) : (
                        <Avatar sx={{ mr: 2, width: 32, height: 32 }}>
                          {option.name.charAt(0)}
                        </Avatar>
                      )}

                      <Box>
                        <Typography variant="body2">{option.name}</Typography>
                        {/* <Typography variant="caption" color="text.secondary">
                          {option.skillLevel}
                        </Typography> */}
                      </Box>
                    </Box>
                  )}
                />
              </CardContent>
            </Card>

            {/* Add custom waiting member */}
            <Card sx={{ mb: 2 }}>
              <CardContent>
                <Typography
                  variant="subtitle1"
                  gutterBottom
                  sx={{ display: "flex", alignItems: "center" }}
                >
                  <Add sx={{ mr: 1 }} />
                  Th√™m t√™n t√πy ch·ªânh v√†o s·∫£nh ch·ªù
                </Typography>
                <Box sx={{ display: "flex", gap: 1 }}>
                  <TextField
                    size="small"
                    label="T√™n th√†nh vi√™n"
                    placeholder="Nh·∫≠p t√™n..."
                    value={customWaitingMemberName}
                    onChange={(e) => setCustomWaitingMemberName(e.target.value)}
                    onKeyPress={(e) =>
                      e.key === "Enter" && addCustomWaitingMember()
                    }
                    sx={{ flexGrow: 1 }}
                  />
                  <FormControlLabel
                    control={
                      <Checkbox
                        onChange={(e) =>
                          setCustomWaitingMemberIsWoman(e.target.checked)
                        }
                        name="isWoman"
                      />
                    }
                    label="N·ªØ"
                  />
                  <Button
                    variant="contained"
                    onClick={addCustomWaitingMember}
                    disabled={!customWaitingMemberName.trim()}
                    startIcon={<Add />}
                  >
                    Th√™m
                  </Button>
                </Box>
              </CardContent>
            </Card>

            {/* Waiting list */}
            <Card>
              <CardContent>
                <Typography
                  variant="subtitle1"
                  gutterBottom
                  sx={{ display: "flex", alignItems: "center" }}
                >
                  <Schedule sx={{ mr: 1 }} />
                  Danh s√°ch ch·ªù ({waitingList.length})
                </Typography>
                {waitingList.length === 0 ? (
                  <Alert severity="info">
                    S·∫£nh ch·ªù tr·ªëng. Th√†nh vi√™n s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y khi danh
                    s√°ch ch√≠nh ƒë√£ ƒë·∫ßy.
                  </Alert>
                ) : (
                  <List dense>
                    {waitingList.map((member, index) => (
                      <ListItem
                        key={member.id}
                        divider={index < waitingList.length - 1}
                      >
                        <ListItemAvatar>
                          {member.avatar ? (
                            <Avatar
                              src={member.avatar}
                              sx={{ mr: 2, width: 32, height: 32 }}
                            />
                          ) : (
                            <Avatar
                              sx={{
                                bgcolor: member.isCustom
                                  ? "secondary.main"
                                  : "warning.main",
                              }}
                            >
                              {member.isCustom ? <Person /> : index + 1}
                            </Avatar>
                          )}
                        </ListItemAvatar>
                        <ListItemText
                          primary={`${index + 1}. ${member.name}`}
                          secondary={
                            member.isCustom ? "T√™n t√πy ch·ªânh" : "Th√†nh vi√™n"
                          }
                        />
                        <ListItemSecondaryAction>
                          <Tooltip title="Chuy·ªÉn v√†o danh s√°ch ch√≠nh">
                            <IconButton
                              onClick={() => moveFromWaitingToMain(member)}
                              size="small"
                              disabled={
                                selectedMembers.length >=
                                formik.values.maxParticipants
                              }
                              color="primary"
                            >
                              <MoveUp />
                            </IconButton>
                          </Tooltip>
                          <Tooltip title="X√≥a kh·ªèi s·∫£nh ch·ªù">
                            <IconButton
                              edge="end"
                              onClick={() => removeFromWaitingList(member)}
                              size="small"
                              color="error"
                            >
                              <Delete />
                            </IconButton>
                          </Tooltip>
                        </ListItemSecondaryAction>
                      </ListItem>
                    ))}
                  </List>
                )}
              </CardContent>
            </Card>
          </Box>
        );
      case 3:
        const totalFixedCost = courtCost + shuttlecockCount * shuttlecockPrice;
        const totalExpenses = expenses.reduce(
          (sum, exp) => sum + exp.amount,
          0
        );
        const totalCost = totalFixedCost + totalExpenses;
        const allMembers = [...selectedMembers, ...waitingList];

        return (
          <Box sx={{ pt: 2 }}>
            <Typography
              variant="h6"
              gutterBottom
              sx={{ display: "flex", alignItems: "center" }}
            >
              <AttachMoney sx={{ mr: 1 }} />
              Chi ph√≠ d·ª± ki·∫øn
            </Typography>

            {/* Court Cost */}
            <Card sx={{ mb: 2 }}>
              <CardContent>
                <Typography
                  variant="subtitle1"
                  gutterBottom
                  sx={{ display: "flex", alignItems: "center" }}
                >
                  <SportsTennis sx={{ mr: 1 }} />
                  Ti·ªÅn s√¢n
                </Typography>
                <TextField
                  fullWidth
                  label="S·ªë ti·ªÅn s√¢n (VNƒê)"
                  type="number"
                  value={courtCost}
                  onChange={(e) => setCourtCost(Number(e.target.value))}
                  helperText="M·∫∑c ƒë·ªãnh l√† 0, c√≥ th·ªÉ t√πy ch·ªânh"
                  InputProps={{
                    startAdornment: (
                      <AttachMoney sx={{ mr: 1, color: "text.secondary" }} />
                    ),
                  }}
                />
              </CardContent>
            </Card>

            {/* Shuttlecock Cost */}
            <Card sx={{ mb: 2 }}>
              <CardContent>
                <Typography variant="subtitle1" gutterBottom>
                  Ti·ªÅn c·∫ßu
                </Typography>
                <Grid container spacing={2}>
                  <Grid item xs={6}>
                    <TextField
                      fullWidth
                      label="S·ªë l∆∞·ª£ng qu·∫£ c·∫ßu"
                      type="number"
                      value={shuttlecockCount}
                      onChange={(e) =>
                        setShuttlecockCount(Number(e.target.value))
                      }
                      inputProps={{ min: 0 }}
                    />
                  </Grid>
                  <Grid item xs={6}>
                    <TextField
                      fullWidth
                      label="Gi√° m·ªói qu·∫£ (VNƒê)"
                      type="number"
                      value={shuttlecockPrice}
                      onChange={(e) =>
                        setShuttlecockPrice(Number(e.target.value))
                      }
                      inputProps={{ min: 0 }}
                    />
                  </Grid>
                </Grid>
                <Typography
                  variant="body2"
                  color="primary"
                  sx={{ mt: 1, fontWeight: "medium" }}
                >
                  T·ªïng ti·ªÅn c·∫ßu:{" "}
                  {formatCurrency(shuttlecockCount * shuttlecockPrice)}
                </Typography>
              </CardContent>
            </Card>

            <Alert severity="info" sx={{ mb: 2 }}>
              <Typography variant="body2">
                <strong>Ti·ªÅn s√¢n v√† ti·ªÅn c·∫ßu</strong> s·∫Ω ƒë∆∞·ª£c chia ƒë·ªÅu cho{" "}
                <strong>{selectedMembers.length} ng∆∞·ªùi tham gia</strong>
                {selectedMembers.length > 0 && (
                  <span>
                    {" "}
                    ({formatCurrency(totalFixedCost / selectedMembers.length)}
                    /ng∆∞·ªùi)
                  </span>
                )}
              </Typography>
            </Alert>
            {/* Additional Expenses */}
            <Card sx={{ mb: 2 }}>
              <CardContent>
                <Box
                  sx={{
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    mb: 2,
                  }}
                >
                  <Typography variant="subtitle1">Chi ph√≠ b·ªï sung</Typography>
                  <Button
                    startIcon={<Add />}
                    onClick={addExpense}
                    size="small"
                    variant="outlined"
                  >
                    Th√™m kho·∫£n chi
                  </Button>
                </Box>

                {expenses.length === 0 ? (
                  <Typography
                    variant="body2"
                    color="text.secondary"
                    sx={{ textAlign: "center", py: 2 }}
                  >
                    Ch∆∞a c√≥ kho·∫£n chi b·ªï sung n√†o
                  </Typography>
                ) : (
                  expenses.map((expense, index) => (
                    <Paper
                      key={expense.id}
                      sx={{ p: 2, mb: 2, bgcolor: "action.hover" }}
                    >
                      <Grid container spacing={2}>
                        <Grid item xs={12} sm={6}>
                          <TextField
                            fullWidth
                            size="small"
                            label="T√™n chi ph√≠"
                            placeholder="VD: N∆∞·ªõc u·ªëng, ƒë·ªì ƒÉn..."
                            value={expense.name}
                            onChange={(e) =>
                              updateExpense(expense.id, "name", e.target.value)
                            }
                          />
                        </Grid>
                        <Grid item xs={12} sm={4}>
                          <TextField
                            fullWidth
                            size="small"
                            label="S·ªë ti·ªÅn (VNƒê)"
                            type="number"
                            value={expense.amount}
                            onChange={(e) =>
                              updateExpense(
                                expense.id,
                                "amount",
                                Number(e.target.value)
                              )
                            }
                            inputProps={{ min: 0 }}
                          />
                        </Grid>
                        <Grid item xs={12} sm={2}>
                          <Tooltip title="X√≥a kho·∫£n chi n√†y">
                            <IconButton
                              onClick={() => removeExpense(expense.id)}
                              color="error"
                              size="small"
                            >
                              <Delete />
                            </IconButton>
                          </Tooltip>
                        </Grid>

                        <Grid item xs={12}>
                          <TextField
                            fullWidth
                            size="small"
                            label="M√¥ t·∫£"
                            placeholder="M√¥ t·∫£ chi ti·∫øt v·ªÅ kho·∫£n chi..."
                            value={expense.description}
                            onChange={(e) =>
                              updateExpense(
                                expense.id,
                                "description",
                                e.target.value
                              )
                            }
                          />
                        </Grid>

                        <Grid item xs={12}>
                          <Typography variant="body2" gutterBottom>
                            Ng∆∞·ªùi chia ti·ªÅn cho kho·∫£n n√†y:
                          </Typography>
                          <Autocomplete
                            multiple
                            options={allMembers}
                            getOptionLabel={(option) => option.name}
                            value={allMembers.filter((m) =>
                              expense.assignedMembers.includes(m.id)
                            )}
                            onChange={(_, newValue) => {
                              updateExpense(
                                expense.id,
                                "assignedMembers",
                                newValue.map((m) => m.id)
                              );
                            }}
                            renderTags={(value, getTagProps) =>
                              value.map((option, index) => (
                                <Chip
                                  variant="outlined"
                                  label={option.name}
                                  {...getTagProps({ index })}
                                  key={option.id}
                                  avatar={
                                    option.avatar ? (
                                      <Avatar
                                        src={option.avatar}
                                        sx={{ mr: 2, width: 32, height: 32 }}
                                      />
                                    ) : (
                                      <Avatar
                                        sx={{
                                          bgcolor: option.isCustom
                                            ? "secondary.main"
                                            : "primary.main",
                                        }}
                                      >
                                        {option.isCustom ? (
                                          <Person />
                                        ) : (
                                          option.name.charAt(0)
                                        )}
                                      </Avatar>
                                    )
                                  }
                                />
                              ))
                            }
                            renderInput={(params) => (
                              <TextField
                                {...params}
                                size="small"
                                placeholder="Ch·ªçn ng∆∞·ªùi chia ti·ªÅn ho·∫∑c ƒë·ªÉ tr·ªëng ƒë·ªÉ chia cho t·∫•t c·∫£"
                                helperText={
                                  expense.assignedMembers.length === 0
                                    ? "S·∫Ω chia ƒë·ªÅu cho t·∫•t c·∫£ th√†nh vi√™n tham gia"
                                    : `Chia cho ${expense.assignedMembers.length} ng∆∞·ªùi ƒë∆∞·ª£c ch·ªçn`
                                }
                              />
                            )}
                            renderOption={(props, option) => (
                              <Box component="li" {...props}>
                                {option.avatar ? (
                                  <Avatar
                                    src={option.avatar}
                                    sx={{ mr: 2, width: 32, height: 32 }}
                                  />
                                ) : (
                                  <Avatar
                                    sx={{
                                      mr: 2,
                                      width: 32,
                                      height: 32,
                                      bgcolor: option.isCustom
                                        ? "secondary.main"
                                        : "primary.main",
                                    }}
                                  >
                                    {option.isCustom ? (
                                      <Person />
                                    ) : (
                                      option.name.charAt(0)
                                    )}
                                  </Avatar>
                                )}

                                <Box>
                                  <Typography variant="body2">
                                    {option.name}
                                  </Typography>
                                  <Typography
                                    variant="caption"
                                    color="text.secondary"
                                  >
                                    {option.isCustom
                                      ? "T√™n t√πy ch·ªânh"
                                      : "Th√†nh vi√™n"}
                                  </Typography>
                                </Box>
                              </Box>
                            )}
                          />
                        </Grid>
                      </Grid>
                    </Paper>
                  ))
                )}
              </CardContent>
            </Card>
            {/* Cost Summary */}
            <Card>
              <CardContent>
                <Typography variant="subtitle1" gutterBottom>
                  T·ªïng k·∫øt chi ph√≠
                </Typography>
                <Box
                  sx={{
                    display: "flex",
                    justifyContent: "space-between",
                    mb: 1,
                  }}
                >
                  <Typography>Ti·ªÅn s√¢n:</Typography>
                  <Typography fontWeight="medium">
                    {formatCurrency(courtCost)}
                  </Typography>
                </Box>
                <Box
                  sx={{
                    display: "flex",
                    justifyContent: "space-between",
                    mb: 1,
                  }}
                >
                  <Typography>Ti·ªÅn c·∫ßu:</Typography>
                  <Typography fontWeight="medium">
                    {formatCurrency(shuttlecockCount * shuttlecockPrice)}
                  </Typography>
                </Box>
                <Box
                  sx={{
                    display: "flex",
                    justifyContent: "space-between",
                    mb: 1,
                  }}
                >
                  <Typography>Chi ph√≠ b·ªï sung:</Typography>
                  <Typography fontWeight="medium">
                    {formatCurrency(totalExpenses)}
                  </Typography>
                </Box>
                <Divider sx={{ my: 1 }} />
                <Box
                  sx={{
                    display: "flex",
                    justifyContent: "space-between",
                    mb: 2,
                  }}
                >
                  <Typography variant="h6" fontWeight="bold">
                    T·ªïng c·ªông:
                  </Typography>
                  <Typography
                    variant="h6"
                    fontWeight="bold"
                    color="primary.main"
                  >
                    {formatCurrency(totalCost)}
                  </Typography>
                </Box>

                <Alert severity="success">
                  <Typography variant="body2">
                    <strong>Chi ph√≠ c·ªë ƒë·ªãnh/ng∆∞·ªùi:</strong>{" "}
                    {formatCurrency(
                      selectedMembers.length > 0
                        ? totalFixedCost / selectedMembers.length
                        : 0
                    )}
                    <br />
                    <strong>S·ªë ng∆∞·ªùi chia:</strong> {selectedMembers.length}{" "}
                    ng∆∞·ªùi tham gia
                    {totalExpenses > 0 && (
                      <>
                        <br />
                        <strong>Chi ph√≠ b·ªï sung:</strong> Chia theo l·ª±a ch·ªçn
                        ri√™ng
                      </>
                    )}
                  </Typography>
                </Alert>
              </CardContent>
            </Card>
          </Box>
        );

      default:
        return "Unknown step";
    }
  };

  const isLoading =
    createSessionMutation.isPending || updateSessionMutation.isPending;

  return (
    <Dialog open={open} onClose={handleClose} maxWidth="md" fullWidth>
      <DialogTitle sx={{ pb: 1 }}>
        <Typography variant="h5" component="div">
          {editingSession ? "Ch·ªânh s·ª≠a l·ªãch ƒë√°nh" : "T·∫°o l·ªãch ƒë√°nh m·ªõi"}
        </Typography>
        <Typography variant="body2" color="text.secondary">
          {editingSession
            ? "C·∫≠p nh·∫≠t th√¥ng tin l·ªãch ƒë√°nh"
            : "T·∫°o l·ªãch ƒë√°nh c·∫ßu l√¥ng m·ªõi"}
        </Typography>
      </DialogTitle>

      <DialogContent>
        <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
          {steps.map((label, index) => (
            <Step key={label}>
              <StepLabel>
                <Typography variant={activeStep === index ? "body1" : "body2"}>
                  {label}
                </Typography>
              </StepLabel>
            </Step>
          ))}
        </Stepper>

        {getStepContent(activeStep)}
      </DialogContent>

      <DialogActions sx={{ px: 3, pb: 3 }}>
        <Button onClick={handleClose} size="large">
          H·ªßy
        </Button>
        <Box sx={{ flex: "1 1 auto" }} />
        {activeStep !== 0 && (
          <Button
            onClick={() => setActiveStep(activeStep - 1)}
            size="large"
            disabled={isLoading}
          >
            Quay l·∫°i
          </Button>
        )}
        <Button
          variant="contained"
          component="button"
          onClick={() => formik.handleSubmit()}
          disabled={isLoading}
          size="large"
          sx={{ minWidth: 120 }}
        >
          {isLoading ? (
            <CircularProgress size={20} color="inherit" />
          ) : activeStep === steps.length - 1 ? (
            editingSession ? (
              "C·∫≠p nh·∫≠t l·ªãch"
            ) : (
              "T·∫°o l·ªãch"
            )
          ) : (
            "Ti·∫øp theo"
          )}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default SessionForm;
